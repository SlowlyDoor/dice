<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>üé≤ 3D –ö—É–±–∏–∫</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
  <style>
    body {
      margin: 0;
      background: radial-gradient(#111, #000);
      overflow: hidden;
    }
    #scene {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    #ui {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
    }
    button {
      font-size: 18px;
      padding: 10px 20px;
      margin: 10px;
      border: none;
      border-radius: 8px;
      background: #00bfff;
      color: white;
      cursor: pointer;
    }
    #result {
      color: white;
      font-size: 20px;
    }
  </style>
</head>
<body>
<canvas id="scene"></canvas>

<div id="ui">
  <button onclick="rollDice()">üé≤ –ë—Ä–æ—Å–∏—Ç—å</button>
  <div id="result">–û–∂–∏–¥–∞–Ω–∏–µ...</div>
</div>

<script>
const tg = Telegram.WebApp;
tg.expand();

// –°—Ü–µ–Ω–∞
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 5;
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("scene"), alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);

// –°–≤–µ—Ç
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(2, 3, 5);
scene.add(light);

// –ì—Ä–∞–Ω–∏ —Å —Ç–æ—á–∫–∞–º–∏ (–º–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ PNG-—Ç–µ–∫—Å—Ç—É—Ä—ã)
const createDotTexture = (count) => {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 128;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, 128, 128);
  ctx.fillStyle = 'black';
  const drawDot = (x, y) => ctx.beginPath(), ctx.arc(x, y, 10, 0, 2*Math.PI), ctx.fill();
  const pos = [[64,64], [32,32],[96,96], [32,96],[96,32], [64,32],[64,96]];
  if(count === 1) drawDot(...pos[0]);
  if(count === 2) pos.slice(1,3).forEach(p=>drawDot(...p));
  if(count === 3) [0,1,2].forEach(i=>drawDot(...pos[i]));
  if(count === 4) pos.slice(1,5).forEach(p=>drawDot(...p));
  if(count === 5) [...pos.slice(1,5),pos[0]].forEach(p=>drawDot(...p));
  if(count === 6) pos.slice(1).forEach(p=>drawDot(...p));
  const texture = new THREE.CanvasTexture(canvas);
  return new THREE.MeshStandardMaterial({ map: texture });
};

// –ö—É–±
const diceMaterials = [
  createDotTexture(1), // Right
  createDotTexture(6), // Left
  createDotTexture(3), // Top
  createDotTexture(4), // Bottom
  createDotTexture(2), // Front
  createDotTexture(5), // Back
];

const dice = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), diceMaterials);
scene.add(dice);

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ü–µ–Ω—ã
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// –ü–æ–≤–æ—Ä–æ—Ç—ã –∫—É–±–∞ –∫ –Ω—É–∂–Ω–æ–π –≥—Ä–∞–Ω–∏
const faceRotations = {
  1: { x: 0, y: 0 },
  2: { x: 0, y: Math.PI },
  3: { x: -Math.PI / 2, y: 0 },
  4: { x: Math.PI / 2, y: 0 },
  5: { x: 0, y: -Math.PI / 2 },
  6: { x: 0, y: Math.PI / 2 },
};

// –ê–Ω–∏–º–∞—Ü–∏—è –±—Ä–æ—Å–∫–∞
function rollDice() {
  const face = Math.floor(Math.random() * 6) + 1;
  const target = faceRotations[face];

  gsap.to(dice.rotation, {
    x: target.x + Math.PI * 6,
    y: target.y + Math.PI * 6,
    duration: 2,
    ease: "power2.out",
    onComplete: () => {
      document.getElementById("result").textContent = `–í—ã–ø–∞–ª–æ: ${face}`;
    }
  });
}
</script>
</body>
</html>
